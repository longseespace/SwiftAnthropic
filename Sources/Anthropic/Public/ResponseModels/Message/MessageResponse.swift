//
//  MessageResponse.swift
//
//
//  Created by James Rochabrun on 1/28/24.
//

import Foundation

/// [Message Response](https://docs.anthropic.com/claude/reference/messages_post)
public struct MessageResponse: Decodable {
   /// Unique object identifier.
   ///
   /// The format and length of IDs may change over time.
   public let id: String
   
   /// e.g: "message"
   public let type: String
   
   /// The model that handled the request.
   public let model: String
   
   /// Conversational role of the generated message.
   ///
   /// This will always be "assistant".
   public let role: String
   
   /// Array of Content objects representing blocks of content generated by the model.
   ///
   /// Each content block has a `type` that determines its structure.
   ///
   /// - Example text:
   ///   ```
   ///   [{"type": "text", "text": "Hi, I'm Claude."}]
   ///   ```
   ///
   /// - Example thinking:
   ///   ```
   ///   [{"type": "thinking", "thinking": "To approach this, let's think about...", "signature": "zbbJhb..."}]
   ///   ```
   ///
   /// - Example tool use:
   ///   ```
   ///   [{"type": "tool_use", "id": "toolu_01A09q90qw90lq917835lq9", "name": "get_weather", "input": { "location": "San Francisco, CA", "unit": "celsius"}}]
   ///   ```
   /// This structure facilitates the integration and manipulation of model-generated content within your application.
   public let content: [Content]
   
   /// indicates why the process was halted.
   ///
   /// This property can hold one of the following values to describe the stop reason:
   /// - `"end_turn"`: The model reached a natural stopping point.
   /// - `"max_tokens"`: The requested `max_tokens` limit or the model's maximum token limit was exceeded.
   /// - `"stop_sequence"`: A custom stop sequence provided by you was generated.
   ///
   /// It's important to note that the values for `stopReason` here differ from those in `/v1/complete`, specifically in how `end_turn` and `stop_sequence` are distinguished.
   ///
   /// - In non-streaming mode, `stopReason` is always non-null, indicating the reason for stopping.
   /// - In streaming mode, `stopReason` is null in the `message_start` event and non-null in all other cases, providing context for the stoppage.
   ///
   /// This design allows for a detailed understanding of the process flow and its termination points.
   public let stopReason: String?
   
   /// Which custom stop sequence was generated.
   ///
   /// This value will be non-null if one of your custom stop sequences was generated.
   public let stopSequence: String?
   
   /// Container for the number of tokens used.
   public let usage: Usage
   
   public enum Content: Codable {
      public typealias Input = [String: DynamicContent]
      public typealias Citations = [Citation]
      
      public struct ToolUse: Codable {
         public let id: String
         public let name: String
         public let input: Input
      }
      
      public struct Thinking: Codable {
         public let thinking: String
         public let signature: String?
      }
      
      case text(String, Citations?)
      case toolUse(ToolUse)
      case thinking(Thinking)
      
      private enum CodingKeys: String, CodingKey {
         case type, text, id, name, input, citations, thinking, signature
      }
      
      public enum DynamicContent: Codable {
         case string(String)
         case integer(Int)
         case double(Double)
         case dictionary(Input)
         case array([DynamicContent])
         case bool(Bool)
         case null
         
         public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let intValue = try? container.decode(Int.self) {
               self = .integer(intValue)
            } else if let doubleValue = try? container.decode(Double.self) {
               self = .double(doubleValue)
            } else if let stringValue = try? container.decode(String.self) {
               self = .string(stringValue)
            } else if let boolValue = try? container.decode(Bool.self) {
               self = .bool(boolValue)
            } else if container.decodeNil() {
               self = .null
            } else if let arrayValue = try? container.decode([DynamicContent].self) {
               self = .array(arrayValue)
            } else if let dictionaryValue = try? container.decode([String: DynamicContent].self) {
               self = .dictionary(dictionaryValue)
            } else {
               throw DecodingError.dataCorruptedError(in: container, debugDescription: "Content cannot be decoded")
            }
         }
         
         public func encode(to encoder: any Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
            case .string(let val):
               try container.encode(val)
            case .integer(let val):
               try container.encode(val)
            case .double(let val):
               try container.encode(val)
            case .dictionary(let val):
               try container.encode(val)
            case .array(let val):
               try container.encode(val)
            case .bool(let val):
               try container.encode(val)
            case .null:
               try container.encodeNil()
            }
         }
      }
      
      public init(from decoder: Decoder) throws {
         let container = try decoder.container(keyedBy: CodingKeys.self)
         let type = try container.decode(String.self, forKey: .type)
         switch type {
         case "text":
            let text = try container.decode(String.self, forKey: .text)
            let citations = try container.decodeIfPresent(Citations.self, forKey: .citations)
            self = .text(text, citations)
         case "tool_use":
            let id = try container.decode(String.self, forKey: .id)
            let name = try container.decode(String.self, forKey: .name)
            let input = try container.decode(Input.self, forKey: .input)
            self = .toolUse(ToolUse(id: id, name: name, input: input))
         case "thinking":
            let thinking = try container.decode(String.self, forKey: .thinking)
            let signature = try container.decodeIfPresent(String.self, forKey: .signature)
            self = .thinking(Thinking(thinking: thinking, signature: signature))
         default:
            throw DecodingError.dataCorruptedError(forKey: .type, in: container, debugDescription: "Invalid type value found in JSON!")
         }
      }
      
      public func encode(to encoder: any Encoder) throws {
         var container = encoder.container(keyedBy: CodingKeys.self)
         switch self {
         case .text(let text, let citations):
            try container.encode("text", forKey: .type)
            try container.encode(text, forKey: .text)
            try container.encodeIfPresent(citations, forKey: .citations)
         case .toolUse(let toolUse):
            try container.encode("tool_use", forKey: .type)
            try container.encode(toolUse.id, forKey: .id)
            try container.encode(toolUse.name, forKey: .name)
            try container.encode(toolUse.input, forKey: .input)
         case .thinking(let thinking):
            try container.encode("thinking", forKey: .type)
            try container.encode(thinking.thinking, forKey: .thinking)
            try container.encodeIfPresent(thinking.signature, forKey: .signature)
         }
      }
   }
   
   /// Claude is capable of providing detailed citations when answering questions about documents, helping you track and verify information sources in responses.
   /// https://docs.anthropic.com/en/docs/build-with-claude/citations
   public enum Citation: Codable {
      case charLocation(CharLocation)
      case pageLocation(PageLocation)
      case contentBlockLocation(ContentBlockLocation)
      
      private enum CodingKeys: String, CodingKey {
         case type, citedText, documentIndex, documentTitle
         case startCharIndex, endCharIndex
         case startPageNumber, endPageNumber
         case startBlockIndex, endBlockIndex
      }
      
      public struct CharLocation: Codable {
         public let citedText: String?
         public let documentIndex: Int?
         public let documentTitle: String?
         public let startCharIndex: Int?
         public let endCharIndex: Int?
      }
      
      public struct PageLocation: Codable {
         public let citedText: String?
         public let documentIndex: Int?
         public let documentTitle: String?
         public let startPageNumber: Int?
         public let endPageNumber: Int?
      }
      
      public struct ContentBlockLocation: Codable {
         public let citedText: String?
         public let documentIndex: Int?
         public let documentTitle: String?
         public let startBlockIndex: Int?
         public let endBlockIndex: Int?
      }
      
      public init(from decoder: Decoder) throws {
         let container = try decoder.container(keyedBy: CodingKeys.self)
         let type = try container.decode(String.self, forKey: .type)
         
         switch type {
         case "char_location":
            self = .charLocation(CharLocation(
               citedText: try container.decodeIfPresent(String.self, forKey: .citedText),
               documentIndex: try container.decodeIfPresent(Int.self, forKey: .documentIndex),
               documentTitle: try container.decodeIfPresent(String.self, forKey: .documentTitle),
               startCharIndex: try container.decodeIfPresent(Int.self, forKey: .startCharIndex),
               endCharIndex: try container.decodeIfPresent(Int.self, forKey: .endCharIndex)
            ))
         case "page_location":
            self = .pageLocation(PageLocation(
               citedText: try container.decodeIfPresent(String.self, forKey: .citedText),
               documentIndex: try container.decodeIfPresent(Int.self, forKey: .documentIndex),
               documentTitle: try container.decodeIfPresent(String.self, forKey: .documentTitle),
               startPageNumber: try container.decodeIfPresent(Int.self, forKey: .startPageNumber),
               endPageNumber: try container.decodeIfPresent(Int.self, forKey: .endPageNumber)
            ))
         case "content_block_location":
            self = .contentBlockLocation(ContentBlockLocation(
               citedText: try container.decodeIfPresent(String.self, forKey: .citedText),
               documentIndex: try container.decodeIfPresent(Int.self, forKey: .documentIndex),
               documentTitle: try container.decodeIfPresent(String.self, forKey: .documentTitle),
               startBlockIndex: try container.decodeIfPresent(Int.self, forKey: .startBlockIndex),
               endBlockIndex: try container.decodeIfPresent(Int.self, forKey: .endBlockIndex)
            ))
         default:
            throw DecodingError.dataCorruptedError(forKey: .type, in: container, debugDescription: "Invalid citation type!")
         }
      }
      
      public func encode(to encoder: Encoder) throws {
         var container = encoder.container(keyedBy: CodingKeys.self)
         
         switch self {
         case .charLocation(let location):
            try container.encode("char_location", forKey: .type)
            try container.encodeIfPresent(location.citedText, forKey: .citedText)
            try container.encodeIfPresent(location.documentIndex, forKey: .documentIndex)
            try container.encodeIfPresent(location.documentTitle, forKey: .documentTitle)
            try container.encodeIfPresent(location.startCharIndex, forKey: .startCharIndex)
            try container.encodeIfPresent(location.endCharIndex, forKey: .endCharIndex)
         case .pageLocation(let location):
            try container.encode("page_location", forKey: .type)
            try container.encodeIfPresent(location.citedText, forKey: .citedText)
            try container.encodeIfPresent(location.documentIndex, forKey: .documentIndex)
            try container.encodeIfPresent(location.documentTitle, forKey: .documentTitle)
            try container.encodeIfPresent(location.startPageNumber, forKey: .startPageNumber)
            try container.encodeIfPresent(location.endPageNumber, forKey: .endPageNumber)
         case .contentBlockLocation(let location):
            try container.encode("content_block_location", forKey: .type)
            try container.encodeIfPresent(location.citedText, forKey: .citedText)
            try container.encodeIfPresent(location.documentIndex, forKey: .documentIndex)
            try container.encodeIfPresent(location.documentTitle, forKey: .documentTitle)
            try container.encodeIfPresent(location.startBlockIndex, forKey: .startBlockIndex)
            try container.encodeIfPresent(location.endBlockIndex, forKey: .endBlockIndex)
         }
      }
   }
   
   public struct Usage: Codable {
      /// The number of input tokens which were used.
      public let inputTokens: Int?
      
      /// The number of output tokens which were used.
      public let outputTokens: Int
      
      /// The number of thinking tokens which were used (when thinking mode is enabled).
      public let thinkingTokens: Int?
      
      /// [Prompt Caching](https://docs.anthropic.com/en/docs/build-with-claude/prompt-caching#how-can-i-track-the-effectiveness-of-my-caching-strategy)
      /// You can monitor cache performance using the cache_creation_input_tokens and cache_read_input_tokens fields in the API response.
      public let cacheCreationInputTokens: Int?
      
      /// [Prompt Caching](https://docs.anthropic.com/en/docs/build-with-claude/prompt-caching#how-can-i-track-the-effectiveness-of-my-caching-strategy)
      /// You can monitor cache performance using the cache_creation_input_tokens and cache_read_input_tokens fields in the API response.
      public let cacheReadInputTokens: Int?
   }
}

/// Extension to provide convenient access to thinking content
extension MessageResponse {
   
   /// Extracts all thinking content blocks from the response
   /// - Returns: Array of thinking content or empty array if none found
   public func getThinkingContent() -> [Content.Thinking] {
      return content.compactMap { contentBlock in
         if case .thinking(let thinking) = contentBlock {
            return thinking
         }
         return nil
      }
   }
   
   /// Get the first thinking content block from the response
   /// - Returns: The first thinking content block or nil if none exists
   public func getFirstThinkingContent() -> Content.Thinking? {
      return getThinkingContent().first
   }
   
   /// Get the combined thinking content as a single string
   /// - Returns: All thinking content concatenated into a single string, or nil if no thinking content exists
   public func getCombinedThinkingContent() -> String? {
      let thinkingBlocks = getThinkingContent()
      if thinkingBlocks.isEmpty {
         return nil
      }
      
      return thinkingBlocks.map { $0.thinking }.joined(separator: "\n\n")
   }
   
   /// Determines if the response contains any thinking content
   /// - Returns: True if thinking content exists, false otherwise
   public var hasThinkingContent: Bool {
      return content.contains { contentBlock in
         if case .thinking = contentBlock {
            return true
         }
         return false
      }
   }
}
